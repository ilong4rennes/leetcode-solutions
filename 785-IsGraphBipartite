class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        UNCOLORED, RED, BLUE = 0, 1, 2  # Define colors
        node_colors = [UNCOLORED] * len(graph)  # Initialize all nodes as uncolored
        
        # Loop through all nodes (to handle disconnected components)
        for node in range(len(graph)):
            # If node is uncolored, start a DFS from it
            if node_colors[node] == UNCOLORED:
                if not self.dfs(node, RED, node_colors, graph):  # Try coloring with RED
                    return False  # Conflict detected during DFS
        
        return True  # All components processed without conflicts
    
    def dfs(self, node, color, node_colors, graph):
        UNCOLORED, RED, BLUE = 0, 1, 2  # Define colors
        node_colors[node] = color  # Color the current node
        neighbor_color = BLUE if color == RED else RED  # Determine neighbor's color
        
        # Check all neighbors
        for neighbor in graph[node]:
            if node_colors[neighbor] == UNCOLORED:  # If neighbor is uncolored, recurse
                if not self.dfs(neighbor, neighbor_color, node_colors, graph):
                    return False  # Conflict detected in the recursion
            elif node_colors[neighbor] != neighbor_color:  # Conflict in coloring
                return False
        
        return True  # No conflicts detected

